#!/usr/bin/env node

/**
 * Universal Service Analyzer
 * Automatically extracts services from website content to generate blog plan
 * Works with any professional service website
 */

const fs = require('fs');
const path = require('path');
const { JSDOM } = require('jsdom');
const fetch = require('node-fetch');

class UniversalServiceAnalyzer {
  constructor() {
    this.services = [];
    this.locations = [];
    this.businessInfo = {};
    this.serviceCategories = [];
    this.detectedIndustry = null;
  }

  /**
   * Analyze local website content
   */
  analyzeLocalWebsite() {
    console.log('üîç Analyzing local website content...');
    
    const sitePaths = [
      'index.html',
      'Home/index.html', 
      'Home/index-updated.html',
      'szolgaltatasok/index.html',
      'services/index.html',
      'about/index.html',
      'rolunk/index.html'
    ];

    let combinedContent = '';
    let foundFiles = [];

    for (const sitePath of sitePaths) {
      const fullPath = path.join(process.cwd(), sitePath);
      if (fs.existsSync(fullPath)) {
        const content = fs.readFileSync(fullPath, 'utf8');
        combinedContent += content + '\n';
        foundFiles.push(sitePath);
        console.log(`üìÑ Found: ${sitePath}`);
      }
    }

    if (foundFiles.length === 0) {
      console.log('‚ùå No website files found. Please ensure website content exists.');
      return null;
    }

    return this.parseWebsiteContent(combinedContent);
  }

  /**
   * Parse website content to extract services
   */
  parseWebsiteContent(htmlContent) {
    const dom = new JSDOM(htmlContent);
    const document = dom.window.document;

    // Extract business info
    this.extractBusinessInfo(document);
    
    // Extract services
    this.extractServices(document);
    
    // Extract locations
    this.extractLocations(document);
    
    // Detect industry
    this.detectIndustry();
    
    // Categorize services
    this.categorizeServices();

    return this.generateAnalysisReport();
  }

  /**
   * Extract business information
   */
  extractBusinessInfo(document) {
    // Business name from title, h1, or meta
    const title = document.querySelector('title')?.textContent || '';
    const h1 = document.querySelector('h1')?.textContent || '';
    const metaDescription = document.querySelector('meta[name="description"]')?.content || '';

    this.businessInfo = {
      name: this.extractBusinessName(title, h1),
      description: metaDescription,
      title: title,
      mainHeading: h1
    };

    console.log(`üè¢ Business: ${this.businessInfo.name}`);
  }

  /**
   * Extract business name from content
   */
  extractBusinessName(title, h1) {
    // Common patterns for business names
    const patterns = [
      /([A-Z√Å√â√ç√ì√ñ≈ê√ö√ú≈∞][a-z√°√©√≠√≥√∂≈ë√∫√º≈±\s]+(?:Kft\.?|Bt\.?|Zrt\.?|Kkt\.?))/,
      /([A-Z√Å√â√ç√ì√ñ≈ê√ö√ú≈∞][a-z√°√©√≠√≥√∂≈ë√∫√º≈±\s]+(?:Szolg√°ltat√°sok|Megold√°sok|Szak√©rt≈ëk?))/,
      /([A-Z√Å√â√ç√ì√ñ≈ê√ö√ú≈∞][a-z√°√©√≠√≥√∂≈ë√∫√º≈±\s]+(?:Mester|Szakember|V√°llalkoz√°s))/,
    ];

    const content = `${title} ${h1}`;
    
    for (const pattern of patterns) {
      const match = content.match(pattern);
      if (match) {
        return match[1].trim();
      }
    }

    // Fallback: first significant capitalized phrase
    const words = content.split(/\s+/).filter(w => w.length > 2);
    const capitalizedWords = words.filter(w => /^[A-Z√Å√â√ç√ì√ñ≈ê√ö√ú≈∞]/.test(w));
    
    if (capitalizedWords.length >= 2) {
      return capitalizedWords.slice(0, 2).join(' ');
    }

    return 'V√°llalkoz√°s';
  }

  /**
   * Extract services from content
   */
  extractServices(document) {
    console.log('üîß Extracting services...');

    const serviceKeywords = [
      // General service indicators
      'szolg√°ltat√°s', 'service', 'munk√°k', 'works', 'v√°llal', 'k√≠n√°l', 'biztos√≠t',
      
      // Construction/Building
      't√©rk√∂vez√©s', 'k≈ëm≈±vess√©g', '√©p√≠t√©s', 'fel√∫j√≠t√°s', 'burkol√°s', 't√°mfal',
      'aszfaltoz', 'betonoz', 'v√≠zelvezet√©s', 'l√©pcs≈ë', 'terasz', 'ker√≠t√©s',
      
      // Automotive
      'szerviz', 'jav√≠t√°s', 'karbantart√°s', 'diagnosztika', 'm≈±szaki', 'aut√≥',
      'gumi', 'f√©k', 'motor', 'v√°lt√≥', 'kl√≠ma', 'elektromos',
      
      // Landscaping/Gardening
      'kert√©sz', 'kerttervez√©s', 'n√∂v√©ny', 'f≈±', '√∂nt√∂z√©s', 'metsz√©s',
      'feny≈ë', 'vir√°g', 'gyep', 'mulcs', 'komposzt',
      
      // Household Services
      'takar√≠t√°s', 'k√∂lt√∂ztet√©s', 'sz√°ll√≠t√°s', 'fest√©s', 'm√°zol√°s', 'tap√©t√°z√°s',
      'villany', 'v√≠zvezet√©k', 'f≈±t√©s', 'kl√≠ma', 'g√°z',
      
      // IT Services
      'weboldal', 'website', 'fejleszt√©s', 'design', 'seo', 'hosting',
      'domain', 'email', 'backup', 'security', 'support',
      
      // Healthcare
      'orvos', 'vizsg√°lat', 'kezel√©s', 'ter√°pia', 'diagnosztika',
      'fog√°sz', 'implant', 'gy√∂k√©r', 'korona', 'feh√©r√≠t√©s',
      
      // Education
      'oktat√°s', 'tan√≠t√°s', 'korrepet', 'nyelv', 'matematika',
      'angol', 'n√©met', 'francia', 'felk√©sz√≠t√©s', 'vizsga'
    ];

    const serviceSelectors = [
      'h2', 'h3', 'h4', // Headings likely to contain services
      '.service', '.szolgaltatas', // Service-specific classes
      'li', // List items
      '.card', '.item', '.block' // Common content blocks
    ];

    const foundServices = new Set();

    // Search through different selectors
    for (const selector of serviceSelectors) {
      const elements = document.querySelectorAll(selector);
      
      elements.forEach(element => {
        const text = element.textContent.toLowerCase();
        
        // Check for service keywords
        for (const keyword of serviceKeywords) {
          if (text.includes(keyword)) {
            const cleanText = this.cleanServiceText(element.textContent);
            if (cleanText.length > 2 && cleanText.length < 100) {
              foundServices.add(cleanText);
            }
          }
        }
      });
    }

    this.services = Array.from(foundServices);
    console.log(`üéØ Found ${this.services.length} services:`, this.services);
  }

  /**
   * Clean service text
   */
  cleanServiceText(text) {
    return text
      .trim()
      .replace(/^[‚Ä¢\-\*\d\.\)]+\s*/, '') // Remove bullets and numbers
      .replace(/\s+/g, ' ') // Normalize whitespace
      .replace(/[^\w\s√°√©√≠√≥√∂≈ë√∫√º≈±√Å√â√ç√ì√ñ≈ê√ö√ú≈∞\-]/g, '') // Keep only letters, numbers, spaces, hyphens
      .trim();
  }

  /**
   * Extract locations from content
   */
  extractLocations(document) {
    console.log('üó∫Ô∏è Extracting locations...');

    const locationKeywords = [
      // Budapest districts
      'I. ker√ºlet', 'II. ker√ºlet', 'III. ker√ºlet', 'IV. ker√ºlet', 'V. ker√ºlet',
      'VI. ker√ºlet', 'VII. ker√ºlet', 'VIII. ker√ºlet', 'IX. ker√ºlet', 'X. ker√ºlet',
      'XI. ker√ºlet', 'XII. ker√ºlet', 'XIII. ker√ºlet', 'XIV. ker√ºlet', 'XV. ker√ºlet',
      'XVI. ker√ºlet', 'XVII. ker√ºlet', 'XVIII. ker√ºlet', 'XIX. ker√ºlet', 'XX. ker√ºlet',
      'XXI. ker√ºlet', 'XXII. ker√ºlet', 'XXIII. ker√ºlet',
      
      // Major Hungarian cities
      'Budapest', 'Debrecen', 'Szeged', 'Miskolc', 'P√©cs', 'Gy≈ër', 'Ny√≠regyh√°za',
      'Kecskem√©t', 'Sz√©kesfeh√©rv√°r', 'Szombathely', 'Sopron', 'Tatab√°nya',
      
      // Pest county cities  
      'Szentendre', 'Budakeszi', 'G√∂d√∂ll≈ë', 'Dunakeszi', 'V√°c', 'Cegl√©d',
      'Monor', 'Dabas', 'Pilisv√∂r√∂sv√°r', 'Buda√∂rs', '√ârd', 'Szigetszentmikl√≥s',
      
      // Counties
      'Pest megye', 'B√°cs-Kiskun megye', 'Baranya megye', 'B√©k√©s megye',
      'Borsod-Aba√∫j-Zempl√©n megye', 'Csongr√°d megye', 'Fej√©r megye'
    ];

    const content = document.body.textContent;
    const foundLocations = new Set();

    for (const location of locationKeywords) {
      if (content.includes(location)) {
        foundLocations.add(location);
      }
    }

    this.locations = Array.from(foundLocations);
    console.log(`üìç Found ${this.locations.length} locations:`, this.locations);
  }

  /**
   * Detect industry based on services
   */
  detectIndustry() {
    const industryKeywords = {
      'construction': [
        't√©rk√∂vez√©s', 'k≈ëm≈±vess√©g', '√©p√≠t√©s', 'fel√∫j√≠t√°s', 'burkol√°s', 'betonoz√°s', 't√°mfal'
      ],
      'automotive': [
        'aut√≥', 'szerviz', 'jav√≠t√°s', 'm≈±szaki', 'gumi', 'f√©k', 'motor', 'diagnosztika'
      ],
      'landscaping': [
        'kert√©sz', 'kerttervez√©s', 'n√∂v√©ny', 'f≈±', '√∂nt√∂z√©s', 'metsz√©s', 'gyep'
      ],
      'household': [
        'takar√≠t√°s', 'k√∂lt√∂ztet√©s', 'fest√©s', 'villany', 'v√≠zvezet√©k', 'f≈±t√©s'
      ],
      'it': [
        'weboldal', 'fejleszt√©s', 'design', 'seo', 'hosting', 'domain', 'support'
      ],
      'healthcare': [
        'orvos', 'vizsg√°lat', 'kezel√©s', 'ter√°pia', 'fog√°sz', 'implant'
      ],
      'education': [
        'oktat√°s', 'tan√≠t√°s', 'korrepet', 'nyelv', 'matematika', 'felk√©sz√≠t√©s'
      ]
    };

    const serviceText = this.services.join(' ').toLowerCase();
    let maxMatches = 0;
    let detectedIndustry = 'general';

    for (const [industry, keywords] of Object.entries(industryKeywords)) {
      let matches = 0;
      for (const keyword of keywords) {
        if (serviceText.includes(keyword)) {
          matches++;
        }
      }
      
      if (matches > maxMatches) {
        maxMatches = matches;
        detectedIndustry = industry;
      }
    }

    this.detectedIndustry = detectedIndustry;
    console.log(`üè≠ Detected industry: ${detectedIndustry} (${maxMatches} matches)`);
  }

  /**
   * Categorize services into groups
   */
  categorizeServices() {
    const categories = {
      primary: [],      // Main services
      secondary: [],    // Support services  
      maintenance: [],  // Ongoing/maintenance
      specialty: []     // Specialized/niche
    };

    const primaryKeywords = ['f≈ë', 'alap', 'main', 'core', 'primary'];
    const maintenanceKeywords = ['karbantart√°s', 'jav√≠t√°s', 'tiszt√≠t√°s', 'maintenance'];
    const specialtyKeywords = ['speci√°lis', 'egyedi', 'pr√©mium', 'luxury', 'custom'];

    this.services.forEach(service => {
      const serviceText = service.toLowerCase();
      
      if (maintenanceKeywords.some(keyword => serviceText.includes(keyword))) {
        categories.maintenance.push(service);
      } else if (specialtyKeywords.some(keyword => serviceText.includes(keyword))) {
        categories.specialty.push(service);
      } else if (primaryKeywords.some(keyword => serviceText.includes(keyword))) {
        categories.primary.push(service);
      } else {
        // Default logic based on industry
        if (this.isLikelyPrimaryService(serviceText)) {
          categories.primary.push(service);
        } else {
          categories.secondary.push(service);
        }
      }
    });

    this.serviceCategories = categories;
    console.log('üìä Service categories:', {
      primary: categories.primary.length,
      secondary: categories.secondary.length, 
      maintenance: categories.maintenance.length,
      specialty: categories.specialty.length
    });
  }

  /**
   * Determine if service is likely primary based on industry
   */
  isLikelyPrimaryService(serviceText) {
    const primaryIndicators = {
      construction: ['t√©rk√∂vez√©s', '√©p√≠t√©s', 'fel√∫j√≠t√°s', 'k≈ëm≈±vess√©g'],
      automotive: ['szerviz', 'jav√≠t√°s', 'diagnosztika', 'm≈±szaki'],
      landscaping: ['kerttervez√©s', 'kert√©p√≠t√©s', 'n√∂v√©ny√ºltet√©s'],
      household: ['takar√≠t√°s', 'k√∂lt√∂ztet√©s', 'fest√©s'],
      it: ['webfejleszt√©s', 'weboldal', 'design', 'seo'],
      healthcare: ['vizsg√°lat', 'kezel√©s', 'ter√°pia'],
      education: ['oktat√°s', 'tan√≠t√°s', 'korrepet√°l√°s']
    };

    const indicators = primaryIndicators[this.detectedIndustry] || [];
    return indicators.some(indicator => serviceText.includes(indicator));
  }

  /**
   * Generate comprehensive analysis report
   */
  generateAnalysisReport() {
    const report = {
      timestamp: new Date().toISOString(),
      businessInfo: this.businessInfo,
      detectedIndustry: this.detectedIndustry,
      services: {
        total: this.services.length,
        list: this.services,
        categories: this.serviceCategories
      },
      locations: {
        total: this.locations.length,
        list: this.locations
      },
      contentMatrix: this.generateContentMatrix(),
      recommendations: this.generateRecommendations()
    };

    return report;
  }

  /**
   * Generate service+location content matrix
   */
  generateContentMatrix() {
    const matrix = [];
    
    const primaryServices = this.serviceCategories.primary.length > 0 
      ? this.serviceCategories.primary 
      : this.services.slice(0, 5); // First 5 if no primary detected

    const primaryLocations = this.locations.slice(0, 10); // Top 10 locations

    for (const service of primaryServices) {
      for (const location of primaryLocations) {
        matrix.push({
          service: service,
          location: location,
          slug: this.generateSlug(`${service}-${location}`),
          priority: this.calculatePriority(service, location)
        });
      }
    }

    return matrix.sort((a, b) => b.priority - a.priority);
  }

  /**
   * Calculate priority for service+location combination
   */
  calculatePriority(service, location) {
    let priority = 50; // Base priority

    // Boost for primary services
    if (this.serviceCategories.primary.includes(service)) {
      priority += 30;
    }

    // Boost for Budapest locations
    if (location.includes('Budapest') || location.includes('ker√ºlet')) {
      priority += 20;
    }

    // Boost for major cities
    const majorCities = ['Debrecen', 'Szeged', 'Miskolc', 'P√©cs', 'Gy≈ër'];
    if (majorCities.some(city => location.includes(city))) {
      priority += 15;
    }

    return priority;
  }

  /**
   * Generate slug from text
   */
  generateSlug(text) {
    return text
      .toLowerCase()
      .replace(/[√°√©√≠√≥√∂≈ë√∫√º≈±]/g, char => {
        const map = {'√°':'a','√©':'e','√≠':'i','√≥':'o','√∂':'o','≈ë':'o','√∫':'u','√º':'u','≈±':'u'};
        return map[char] || char;
      })
      .replace(/[^a-z0-9\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .trim();
  }

  /**
   * Generate recommendations for content strategy
   */
  generateRecommendations() {
    const recommendations = [];

    // Service coverage recommendations
    if (this.services.length < 3) {
      recommendations.push({
        type: 'warning',
        title: 'Kev√©s szolg√°ltat√°s √©szlelve',
        description: 'Csak ' + this.services.length + ' szolg√°ltat√°st tal√°ltam. Ellen≈ërizd, hogy minden szolg√°ltat√°s fel van-e t√ºntetve a weboldalon.'
      });
    }

    // Location coverage recommendations  
    if (this.locations.length < 2) {
      recommendations.push({
        type: 'warning',
        title: 'Kev√©s helysz√≠n √©szlelve',
        description: 'Csak ' + this.locations.length + ' helysz√≠nt tal√°ltam. Add meg pontosan, hogy mely ter√ºleteken dolgozol.'
      });
    }

    // Content volume recommendations
    const contentMatrix = this.generateContentMatrix();
    if (contentMatrix.length > 100) {
      recommendations.push({
        type: 'info',
        title: 'Nagy content lehet≈ës√©g',
        description: `${contentMatrix.length} szolg√°ltat√°s+helysz√≠n kombin√°ci√≥t tal√°ltam. Ez 1+ √©v blog tartalomra elegend≈ë.`
      });
    }

    // Industry-specific recommendations
    recommendations.push({
      type: 'success',
      title: `${this.detectedIndustry} ipar√°g felismerve`,
      description: `A rendszer automatikusan felismerte a szakm√°t. A blog tartalom erre lesz optimaliz√°lva.`
    });

    return recommendations;
  }

  /**
   * Save analysis results
   */
  saveResults(report) {
    const outputDir = path.join(process.cwd(), 'blog');
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Save full analysis
    const analysisPath = path.join(outputDir, 'service-analysis.json');
    fs.writeFileSync(analysisPath, JSON.stringify(report, null, 2));

    // Save content matrix for blog planning
    const matrixPath = path.join(outputDir, 'content-matrix.json');
    fs.writeFileSync(matrixPath, JSON.stringify(report.contentMatrix, null, 2));

    console.log(`‚úÖ Analysis saved to:`);
    console.log(`üìä Full analysis: ${analysisPath}`);
    console.log(`üìã Content matrix: ${matrixPath}`);

    return { analysisPath, matrixPath };
  }

  /**
   * Main execution function
   */
  async run() {
    console.log('\nüöÄ Universal Service Analyzer Starting...\n');

    try {
      const report = this.analyzeLocalWebsite();
      
      if (!report) {
        console.error('‚ùå Analysis failed - no content found');
        process.exit(1);
      }

      const paths = this.saveResults(report);

      // Print summary
      console.log('\nüìä ANALYSIS SUMMARY:');
      console.log('='.repeat(50));
      console.log(`üè¢ Business: ${report.businessInfo.name}`);
      console.log(`üè≠ Industry: ${report.detectedIndustry}`);
      console.log(`üîß Services: ${report.services.total}`);
      console.log(`üìç Locations: ${report.locations.total}`);
      console.log(`üìù Content Opportunities: ${report.contentMatrix.length}`);

      console.log('\nüéØ TOP 10 CONTENT OPPORTUNITIES:');
      console.log('-'.repeat(50));
      report.contentMatrix.slice(0, 10).forEach((item, index) => {
        console.log(`${index + 1:2}. ${item.service} ‚Üí ${item.location} (Priority: ${item.priority})`);
      });

      if (report.recommendations.length > 0) {
        console.log('\nüí° RECOMMENDATIONS:');
        console.log('-'.repeat(50));
        report.recommendations.forEach(rec => {
          const icon = rec.type === 'warning' ? '‚ö†Ô∏è' : rec.type === 'success' ? '‚úÖ' : '‚ÑπÔ∏è';
          console.log(`${icon} ${rec.title}: ${rec.description}`);
        });
      }

      console.log('\nüéâ Analysis complete! Use the generated content matrix for blog planning.');
      
      return report;

    } catch (error) {
      console.error('‚ùå Error during analysis:', error.message);
      process.exit(1);
    }
  }
}

// Run if executed directly
if (require.main === module) {
  const analyzer = new UniversalServiceAnalyzer();
  analyzer.run().catch(error => {
    console.error('üí• Unhandled error:', error);
    process.exit(1);
  });
}

module.exports = UniversalServiceAnalyzer;